#!/usr/local/bin/perl
#
# produce various indexes of html docs
# stolen from tchrist's article in The Perl Journal
# hacked up by trent
#
# generates an anchor for each given html doc
# with the "-i title" it will generate a full html page with "title"
# as the title.
# with the -n option, list all the subsections in each document
#

require 5.002;	 # or 5.001 iff you remove the comments!
require "ctime.pl";
require 'getopts.pl';

my $now = &ctime(time);
(my $prog_name = $0) =~ s|^.*/(.*)|$1|;   # who I am, keep only base name

undef $/;

&Getopts('ani:ts:'); 
my $listnames = $main::opt_n;
my $fullindex = $main::opt_i;
my $articles  = $main::opt_a;
my $table     = $main::opt_t;
$sortfield    = $main::opt_s;

my($title, $filename, $item, $author, $date, @namelist);
my(@list);

while ($filename = shift)
{
    	unless (open(HTML, $filename))
	{
		warn "can't open $filename: $!";
		next;
    	}
    	my $html = <HTML>;
    	my $count = 0;
    	while ( $html =~ m{			 
        	           < \s* TITLE .*? >	        # begin tag
			   \s* (.*?) \s* 	         # contents
			   < \s* / \s* TITLE .*? >	  # end tag
		          }gsix)
	{
		if ($count++)
		{
           		warn "$filename has $count titles!\n";
		} 
		($title = $1 || "UNTITLED") =~ s/\s+/ /g;
    	}

	if ($articles)
	{
		$author = $1
		         if ($html =~ m{<!--AUTHOR--><h\d>(.*?)</h\d>}gsix);
		$date = $1
			 if ($html =~ m{<!--DATE--><h\d>(.*?)</h\d>}gsix);
		unless ($author || $date)
		{
			warn "$filename is not an article\n";
			undef $filename;
			next;
		}
	}
	next unless $listnames;

	pos $html = 0;		# reset pattern matching
	@namelist = ();
	while ( $html =~ m{< \s* A    # this is an anchor
			   \s+ NAME   # a link spec
			   \s* = \s*  # here comes the link
			   ( [\"\'] ) # '"either quote, saved in $1
			   ( .*? )    # the whole link, saved in $2
			   \1         # the original $1 quote
			   .*? >      # the rest of the tag 
			   \s*(.*?)\s* # the contents
			   < \s*/\s* A \s*> # the end tag
		          }xsgi)
	{
		warn "empty NAME for anchor \"$3\"\n" unless $2;
		push(@namelist, [$2, $3]);
	}
	next unless @namelist;
}
continue
{
	push(@list, [$filename, $title, $author, $date, @namelist])
	    if $filename;	
	($title, $filename, $author, $date, @namelist) = ();
}

my($i, $j);

if ($fullindex)
{
	print "<html>\n<head>\n<title>$fullindex</title>\n</head>\n";
	print "<body>\n<h1>$fullindex</h1>\n";

	if ($table)
	{
		print "<table>\n";
		&tableline("th", "Title", "Author", "Date",
			   ($listnames ? "Subsections" : undef));
	}
	else
	{
		print "<ul>\n";
	}
	$item = "  <li>";
}

foreach $i (sort byfield @list)
{
	($filename, $title, $author, $date, @namelist) = @$i;

	if ($listnames)
	{
		@nlist = ();
		foreach $j (@namelist)
		{
			push(@nlist,sprintf("<a href=\"%s\#%s\">%s</a>",
					       $filename, @$j));
		}
	}

	if ($table)
	{
		&tableline("td",
			   sprintf("<a href=\"%s\">%s</a>",
				   $filename, $title),
			   $author, $date, @nlist);
		next;
	}
       	printf "%s<a href=\"%s\">%s</a>\n", $item, $filename, $title;

	print "By $author " if $author;
	print "($date)" if $date;
	print "\n" if $author or $date;

	if ($listnames && !$table)
	{
		print "  <ul>\n" if $fullindex;
		print $item, join("\n$item", @nlist), "\n";
		print "  </ul>\n" if $fullindex;
	}
}
exit 0 unless $fullindex;

if ($table)
{
	print "</table>\n";
}
else
{
	print "</ul>\n";
}
print "generated by $prog_name on $now";
print "</body></html>\n";

exit 0;

sub byfield
{
	my($x, $y);

	if ($sortfield eq "title")
	{
		$x = ${$a}[1];
	        $y = ${$b}[1];
                # remove quotes to keep them from screwing up the sort
		$x =~ s/[\"\'\`]+//g;
		$y =~ s/[\"\'\`]+//g;
		# secondary sort on date
		if ($x eq $y)
		{
			($x = ${$a}[3]) =~ s/(19|20)(\d\d)/$1$2/;
                        ($y = ${$b}[3]) =~ s/(19|20)(\d\d)/$1$2/;
		}
		return $x cmp $y;
	}
	if ($sortfield eq "filename")
	{
		return ${$a}[0] cmp ${$b}[0];
	}
	if ($sortfield eq "author")
	{
		($x = ${$a}[2]) =~ s/<.*?>//g; 
                $x =~ s/(.*) (\S+)\s*$/$2, $1/;
		($y = ${$b}[2]) =~ s/<.*?>//g;
                $y =~ s/(.*) (\S+)\s*$/$2, $1/;
		# secondary sort on date
		if ($x eq $y)
		{
			($x = ${$a}[3]) =~ s/(19|20)(\d\d)/$1$2/;
                        ($y = ${$b}[3]) =~ s/(19|20)(\d\d)/$1$2/;
		}
		return $x cmp $y;
	}
	if ($sortfield eq "date")
	{
		($x = ${$a}[3]) =~ s/(19|20)(\d\d)/$1$2/;
		($y = ${$b}[3]) =~ s/(19|20)(\d\d)/$1$2/;
		return ${$a}[3] <=> ${$b}[3];
	}
return 0;

}
sub tableline
{
	my ($tag, @l) = @_;

	print "  <tr><$tag>", join("</$tag> <$tag>", @l),
	      "</$tag></tr><h6></h6>\n";
}


